第一天之後頭尾皆為零
可以用暴力破解的方式得知:
頭尾皆為零的狀態會形成迴圈, 並且其週期之公倍數為 14





驗證:
1. 建立每一個頭尾皆為 0 之下一步
n = {}
for i in range(2 ** 6):
    j = i << 1
    n[j] = (((j >> 2) ^ j ^ 1) % (2 ** 6)) << 1

{0: 2, 2: 6, 4: 8, 6: 12, 8: 22, 10: 18, 12: 28, 14: 24, 16: 42, 18: 46, 20: 32, 22: 36, 24: 62, 26: 58, 28: 52, 30: 48, 32: 82, 34: 86, 36: 88, 38: 92, 40: 70, 42: 66, 44: 76, 46: 72, 48: 122, 50: 126,
52: 112, 54: 116, 56: 110, 58: 106, 60: 100, 62: 96, 64: 34, 66: 38, 68: 40, 70: 44, 72: 54, 74: 50, 76: 60, 78: 56, 80: 10, 82: 14, 84: 0, 86: 4, 88: 30, 90: 26, 92: 20, 94: 16, 96: 114,
98: 118, 100: 120, 102: 124, 104: 102, 106: 98, 108: 108, 110: 104, 112: 90, 114: 94, 116: 80, 118: 84, 120: 78, 122: 74, 124: 68, 126: 64}

可以看出其分成以下六組, 其週期只有三種不同值: 1, 7, 14, 所以 lcm = 14
[0, 2, 6, 12, 28, 52, 112, 90, 26, 58, 106, 98, 118, 84, 0]
[4, 8, 22, 36, 88, 30, 48, 122, 74, 50, 126, 64, 34, 86, 4]
[10, 18, 46, 72, 54, 116, 80, 10]
[14, 24, 62, 96, 114, 94, 16, 42, 66, 38, 92, 20, 32, 82, 14]
[40, 70, 44, 76, 60, 100, 120, 78, 56, 110, 104, 102, 124, 68, 40]
[108]

2. 每一個都走 14 步, 確認會回到自身
for x in n:
    m = x
    for _ in range(14):
        m = n[m]
    try:
        assert m == x
    except AssertionError:
        print(x, m)

可以確認最多只要走 1(確保進入迴圈) + (N - 1) % 14 次 即可

```python
class Solution:
    def prisonAfterNDays(self, cells, N):
        for _ in range(1 + (N - 1) % 14): cells = [0] + [x ^ y ^ 1 for x, y in zip(cells[2:], cells[:-2])] + [0]
        return cells
```
使用迭代
```python
class Solution:
    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:
        if N == 0: return cells
        return self.prisonAfterNDays([0] + [x ^ y ^ 1 for x, y in zip(cells[:-2], cells[2:])] + [0], (N - 1) % 14)
```